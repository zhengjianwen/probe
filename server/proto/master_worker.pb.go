// Code generated by protoc-gen-go. DO NOT EDIT.
// source: master_worker.proto

/*
Package master_worker is a generated protocol buffer package.

It is generated from these files:
	master_worker.proto

It has these top-level messages:
	Topic
	Task
	BasicInfo
	TaskResult
	HttpSpec
	DnsSpec
	PingSpec
	TraceRouteSpec
	TcpSpec
	UdpSpec
	FtpSpec
*/
package master_worker

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TaskType int32

const (
	TaskType__              TaskType = 0
	TaskType_UNHEALTH_CHECK TaskType = 1
	TaskType_HTTP           TaskType = 2
	TaskType_DNS            TaskType = 3
	TaskType_PING           TaskType = 4
	TaskType_TRACE_ROUTE    TaskType = 5
	TaskType_TCP            TaskType = 6
	TaskType_UDP            TaskType = 7
	TaskType_FTP            TaskType = 8
)

var TaskType_name = map[int32]string{
	0: "_",
	1: "UNHEALTH_CHECK",
	2: "HTTP",
	3: "DNS",
	4: "PING",
	5: "TRACE_ROUTE",
	6: "TCP",
	7: "UDP",
	8: "FTP",
}
var TaskType_value = map[string]int32{
	"_":              0,
	"UNHEALTH_CHECK": 1,
	"HTTP":           2,
	"DNS":            3,
	"PING":           4,
	"TRACE_ROUTE":    5,
	"TCP":            6,
	"UDP":            7,
	"FTP":            8,
}

func (x TaskType) String() string {
	return proto.EnumName(TaskType_name, int32(x))
}
func (TaskType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type TopicType int32

const (
	Topic__             TopicType = 0
	Topic_CONNECT       TopicType = 1
	Topic_RESULT        TopicType = 2
	Topic_HEALTH_REPORT TopicType = 3
)

var TopicType_name = map[int32]string{
	0: "_",
	1: "CONNECT",
	2: "RESULT",
	3: "HEALTH_REPORT",
}
var TopicType_value = map[string]int32{
	"_":             0,
	"CONNECT":       1,
	"RESULT":        2,
	"HEALTH_REPORT": 3,
}

func (x TopicType) String() string {
	return proto.EnumName(TopicType_name, int32(x))
}
func (TopicType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type TaskResultCode int32

const (
	TaskResult__                            TaskResultCode = 0
	TaskResult_OK                           TaskResultCode = 1
	TaskResult_ERR_HTTP_NEW_REQUEST         TaskResultCode = 2
	TaskResult_ERR_HTTP_DO_REQUEST          TaskResultCode = 3
	TaskResult_ERR_HTTP_READ_BODY           TaskResultCode = 4
	TaskResult_ERR_HTTP_STATUS_CODE_UNMATCH TaskResultCode = 5
	TaskResult_ERR_HTTP_HEAD_UNMATCH        TaskResultCode = 6
	TaskResult_ERR_HTTP_BODY_UNMATCH        TaskResultCode = 7
	TaskResult_ERR_HTTP_TIMEOUT             TaskResultCode = 8
	TaskResult_ERR_HTTP_OTHER               TaskResultCode = 9
	TaskResult_ERR_NET_DIAL                 TaskResultCode = 10
	TaskResult_ERR_UDP_REQUEST              TaskResultCode = 11
	TaskResult_ERR_UDP_RESPONSE             TaskResultCode = 12
	TaskResult_ERR_UDP_RESPONSE_UNMATCH     TaskResultCode = 13
	TaskResult_ERR_FTP_UNAUTHORIZED         TaskResultCode = 14
)

var TaskResultCode_name = map[int32]string{
	0:  "_",
	1:  "OK",
	2:  "ERR_HTTP_NEW_REQUEST",
	3:  "ERR_HTTP_DO_REQUEST",
	4:  "ERR_HTTP_READ_BODY",
	5:  "ERR_HTTP_STATUS_CODE_UNMATCH",
	6:  "ERR_HTTP_HEAD_UNMATCH",
	7:  "ERR_HTTP_BODY_UNMATCH",
	8:  "ERR_HTTP_TIMEOUT",
	9:  "ERR_HTTP_OTHER",
	10: "ERR_NET_DIAL",
	11: "ERR_UDP_REQUEST",
	12: "ERR_UDP_RESPONSE",
	13: "ERR_UDP_RESPONSE_UNMATCH",
	14: "ERR_FTP_UNAUTHORIZED",
}
var TaskResultCode_value = map[string]int32{
	"_":  0,
	"OK": 1,
	"ERR_HTTP_NEW_REQUEST":         2,
	"ERR_HTTP_DO_REQUEST":          3,
	"ERR_HTTP_READ_BODY":           4,
	"ERR_HTTP_STATUS_CODE_UNMATCH": 5,
	"ERR_HTTP_HEAD_UNMATCH":        6,
	"ERR_HTTP_BODY_UNMATCH":        7,
	"ERR_HTTP_TIMEOUT":             8,
	"ERR_HTTP_OTHER":               9,
	"ERR_NET_DIAL":                 10,
	"ERR_UDP_REQUEST":              11,
	"ERR_UDP_RESPONSE":             12,
	"ERR_UDP_RESPONSE_UNMATCH":     13,
	"ERR_FTP_UNAUTHORIZED":         14,
}

func (x TaskResultCode) String() string {
	return proto.EnumName(TaskResultCode_name, int32(x))
}
func (TaskResultCode) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

type HttpSpecMethod int32

const (
	HttpSpec___   HttpSpecMethod = 0
	HttpSpec_GET  HttpSpecMethod = 1
	HttpSpec_POST HttpSpecMethod = 2
	HttpSpec_HEAD HttpSpecMethod = 3
)

var HttpSpecMethod_name = map[int32]string{
	0: "__",
	1: "GET",
	2: "POST",
	3: "HEAD",
}
var HttpSpecMethod_value = map[string]int32{
	"__":   0,
	"GET":  1,
	"POST": 2,
	"HEAD": 3,
}

func (x HttpSpecMethod) String() string {
	return proto.EnumName(HttpSpecMethod_name, int32(x))
}
func (HttpSpecMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type HttpSpecMatcherTarget int32

const (
	HttpSpecMatcher____  HttpSpecMatcherTarget = 0
	HttpSpecMatcher_BODY HttpSpecMatcherTarget = 1
	HttpSpecMatcher_HEAD HttpSpecMatcherTarget = 2
)

var HttpSpecMatcherTarget_name = map[int32]string{
	0: "___",
	1: "BODY",
	2: "HEAD",
}
var HttpSpecMatcherTarget_value = map[string]int32{
	"___":  0,
	"BODY": 1,
	"HEAD": 2,
}

func (x HttpSpecMatcherTarget) String() string {
	return proto.EnumName(HttpSpecMatcherTarget_name, int32(x))
}
func (HttpSpecMatcherTarget) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0, 0} }

type HttpSpecMatcherMethod int32

const (
	HttpSpecMatcher______   HttpSpecMatcherMethod = 0
	HttpSpecMatcher_INCLUDE HttpSpecMatcherMethod = 1
	HttpSpecMatcher_EXCLUDE HttpSpecMatcherMethod = 2
)

var HttpSpecMatcherMethod_name = map[int32]string{
	0: "_____",
	1: "INCLUDE",
	2: "EXCLUDE",
}
var HttpSpecMatcherMethod_value = map[string]int32{
	"_____":   0,
	"INCLUDE": 1,
	"EXCLUDE": 2,
}

func (x HttpSpecMatcherMethod) String() string {
	return proto.EnumName(HttpSpecMatcherMethod_name, int32(x))
}
func (HttpSpecMatcherMethod) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0, 1} }

type DnsSpecType int32

const (
	DnsSpec______ DnsSpecType = 0
	DnsSpec_A     DnsSpecType = 1
	DnsSpec_MX    DnsSpecType = 2
	DnsSpec_NS    DnsSpecType = 3
	DnsSpec_CNAME DnsSpecType = 4
	DnsSpec_TXT   DnsSpecType = 5
	DnsSpec_ANY   DnsSpecType = 6
)

var DnsSpecType_name = map[int32]string{
	0: "_____",
	1: "A",
	2: "MX",
	3: "NS",
	4: "CNAME",
	5: "TXT",
	6: "ANY",
}
var DnsSpecType_value = map[string]int32{
	"_____": 0,
	"A":     1,
	"MX":    2,
	"NS":    3,
	"CNAME": 4,
	"TXT":   5,
	"ANY":   6,
}

func (x DnsSpecType) String() string {
	return proto.EnumName(DnsSpecType_name, int32(x))
}
func (DnsSpecType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{5, 0} }

type UdpSpecFormat int32

const (
	UdpSpec__      UdpSpecFormat = 0
	UdpSpec_BINARY UdpSpecFormat = 1
	UdpSpec_TEXT   UdpSpecFormat = 2
)

var UdpSpecFormat_name = map[int32]string{
	0: "_",
	1: "BINARY",
	2: "TEXT",
}
var UdpSpecFormat_value = map[string]int32{
	"_":      0,
	"BINARY": 1,
	"TEXT":   2,
}

func (x UdpSpecFormat) String() string {
	return proto.EnumName(UdpSpecFormat_name, int32(x))
}
func (UdpSpecFormat) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{9, 0} }

type Topic struct {
	Type       TopicType   `protobuf:"varint,1,opt,name=Type,json=type,enum=TopicType" json:"Type,omitempty"`
	WorkerId   int64       `protobuf:"varint,2,opt,name=WorkerId,json=workerId" json:"WorkerId,omitempty"`
	WorkerTime int64       `protobuf:"varint,3,opt,name=WorkerTime,json=workerTime" json:"WorkerTime,omitempty"`
	Result     *TaskResult `protobuf:"bytes,4,opt,name=result" json:"result,omitempty"`
}

func (m *Topic) Reset()                    { *m = Topic{} }
func (m *Topic) String() string            { return proto.CompactTextString(m) }
func (*Topic) ProtoMessage()               {}
func (*Topic) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Topic) GetType() TopicType {
	if m != nil {
		return m.Type
	}
	return Topic__
}

func (m *Topic) GetWorkerId() int64 {
	if m != nil {
		return m.WorkerId
	}
	return 0
}

func (m *Topic) GetWorkerTime() int64 {
	if m != nil {
		return m.WorkerTime
	}
	return 0
}

func (m *Topic) GetResult() *TaskResult {
	if m != nil {
		return m.Result
	}
	return nil
}

type Task struct {
	BasicInfo      *BasicInfo      `protobuf:"bytes,1,opt,name=BasicInfo,json=basicInfo" json:"BasicInfo,omitempty"`
	HttpSpec       *HttpSpec       `protobuf:"bytes,2,opt,name=HttpSpec,json=httpSpec" json:"HttpSpec,omitempty"`
	DnsSpec        *DnsSpec        `protobuf:"bytes,3,opt,name=DnsSpec,json=dnsSpec" json:"DnsSpec,omitempty"`
	PingSpec       *PingSpec       `protobuf:"bytes,4,opt,name=PingSpec,json=pingSpec" json:"PingSpec,omitempty"`
	TracerouteSpec *TraceRouteSpec `protobuf:"bytes,5,opt,name=TracerouteSpec,json=tracerouteSpec" json:"TracerouteSpec,omitempty"`
	TcpSpec        *TcpSpec        `protobuf:"bytes,6,opt,name=TcpSpec,json=tcpSpec" json:"TcpSpec,omitempty"`
	UdpSpec        *UdpSpec        `protobuf:"bytes,7,opt,name=UdpSpec,json=udpSpec" json:"UdpSpec,omitempty"`
	FtpSpec        *FtpSpec        `protobuf:"bytes,8,opt,name=FtpSpec,json=ftpSpec" json:"FtpSpec,omitempty"`
}

func (m *Task) Reset()                    { *m = Task{} }
func (m *Task) String() string            { return proto.CompactTextString(m) }
func (*Task) ProtoMessage()               {}
func (*Task) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Task) GetBasicInfo() *BasicInfo {
	if m != nil {
		return m.BasicInfo
	}
	return nil
}

func (m *Task) GetHttpSpec() *HttpSpec {
	if m != nil {
		return m.HttpSpec
	}
	return nil
}

func (m *Task) GetDnsSpec() *DnsSpec {
	if m != nil {
		return m.DnsSpec
	}
	return nil
}

func (m *Task) GetPingSpec() *PingSpec {
	if m != nil {
		return m.PingSpec
	}
	return nil
}

func (m *Task) GetTracerouteSpec() *TraceRouteSpec {
	if m != nil {
		return m.TracerouteSpec
	}
	return nil
}

func (m *Task) GetTcpSpec() *TcpSpec {
	if m != nil {
		return m.TcpSpec
	}
	return nil
}

func (m *Task) GetUdpSpec() *UdpSpec {
	if m != nil {
		return m.UdpSpec
	}
	return nil
}

func (m *Task) GetFtpSpec() *FtpSpec {
	if m != nil {
		return m.FtpSpec
	}
	return nil
}

type BasicInfo struct {
	Id           int64    `protobuf:"varint,1,opt,name=Id,json=id" json:"Id"`
	OrgId        int64    `protobuf:"varint,2,opt,name=OrgId,json=orgId" json:"OrgId"`
	NodeId       int64    `protobuf:"varint,3,opt,name=NodeId,json=nodeId" json:"NodeId"`
	Type         TaskType `protobuf:"varint,4,opt,name=Type,json=type,enum=TaskType" json:"Type"`
	Name         string   `protobuf:"bytes,5,opt,name=Name,json=name" json:"Name"`
	Version      string   `protobuf:"bytes,6,opt,name=Version,json=version" json:"Version"`
	CreateTime   int64    `protobuf:"varint,7,opt,name=CreateTime,json=createTime" json:"CreateTime"`
	UpdateTime   int64    `protobuf:"varint,8,opt,name=UpdateTime,json=updateTime" json:"UpdateTime"`
	ExecuteTime  int64    `protobuf:"varint,9,opt,name=ExecuteTime,json=executeTime" json:"ExecuteTime"`
	ScheduleTime int64    `protobuf:"varint,10,opt,name=ScheduleTime,json=scheduleTime" json:"ScheduleTime"`
	PeriodSec    int64    `protobuf:"varint,11,opt,name=PeriodSec,json=periodSec" json:"PeriodSec"`
	Stop         bool     `protobuf:"varint,12,opt,name=Stop,json=stop" json:"Stop" xorm:"default false"`
	RuleIds      []int64  `protobuf:"varint,13,rep,packed,name=RuleIds,json=ruleIds" json:"RuleIds" xorm:"rule_ids json"`
}

func (m *BasicInfo) Reset()                    { *m = BasicInfo{} }
func (m *BasicInfo) String() string            { return proto.CompactTextString(m) }
func (*BasicInfo) ProtoMessage()               {}
func (*BasicInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *BasicInfo) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *BasicInfo) GetOrgId() int64 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *BasicInfo) SetOrgId(id int64) {
	if m != nil {
		m.OrgId = id
	}
}

func (m *BasicInfo) GetNodeId() int64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *BasicInfo) SetNodeId(id int64) {
	if m != nil {
		m.NodeId = id
	}
}

func (m *BasicInfo) GetType() TaskType {
	if m != nil {
		return m.Type
	}
	return TaskType__
}

func (m *BasicInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BasicInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *BasicInfo) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *BasicInfo) GetUpdateTime() int64 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

func (m *BasicInfo) GetExecuteTime() int64 {
	if m != nil {
		return m.ExecuteTime
	}
	return 0
}

func (m *BasicInfo) GetScheduleTime() int64 {
	if m != nil {
		return m.ScheduleTime
	}
	return 0
}

func (m *BasicInfo) SetScheduleTime(st int64) {
	if m != nil {
		m.ScheduleTime = st
	}
}

func (m *BasicInfo) GetPeriodSec() int64 {
	if m != nil {
		return m.PeriodSec
	}
	return 0
}

func (m *BasicInfo) GetStop() bool {
	if m != nil {
		return m.Stop
	}
	return false
}

func (m *BasicInfo) GetRuleIds() []int64 {
	if m != nil {
		return m.RuleIds
	}
	return nil
}

func (m *BasicInfo) AddRuleId(id int64) {
	if m != nil {
		if m.RuleIds == nil {
			m.RuleIds = []int64{id}
		} else if !contains(m.RuleIds, id) {
			m.RuleIds = append(m.RuleIds, id)
		}
	}
}

func (m *BasicInfo) RemoveRuleId(id int64) {
	if m != nil && m.RuleIds != nil && contains(m.RuleIds, id) {

		var newRuleIds []int64
		for _, ruleId := range m.RuleIds {
			if ruleId != id {
				newRuleIds = append(newRuleIds, ruleId)
			}
		}
		m.RuleIds = newRuleIds
	}
}

func contains(l []int64, i int64) bool {
	for _, ele := range l {
		if ele == i {
			return true
		}
	}
	return false
}

type TaskResult struct {
	TaskId       int64                 `protobuf:"varint,1,opt,name=TaskId,json=taskId" json:"TaskId,omitempty"`
	OrgId        int64                 `protobuf:"varint,2,opt,name=OrgId,json=orgId" json:"OrgId,omitempty"`
	Type         TaskType              `protobuf:"varint,3,opt,name=Type,json=type,enum=TaskType" json:"Type,omitempty"`
	Success      bool                  `protobuf:"varint,4,opt,name=Success,json=success" json:"Success,omitempty"`
	ErrorCode    TaskResultCode        `protobuf:"varint,5,opt,name=ErrorCode,json=errorCode,enum=TaskResultCode" json:"ErrorCode,omitempty"`
	Error        string                `protobuf:"bytes,6,opt,name=Error,json=error" json:"Error,omitempty"`
	ScheduleTime int64                 `protobuf:"varint,7,opt,name=ScheduleTime,json=scheduleTime" json:"ScheduleTime,omitempty"`
	StartMs      int64                 `protobuf:"varint,8,opt,name=StartMs,json=startMs" json:"StartMs,omitempty"`
	DelayMs      int64                 `protobuf:"varint,9,opt,name=DelayMs,json=delayMs" json:"DelayMs,omitempty"`
	PeriodSec    int64                 `protobuf:"varint,10,opt,name=PeriodSec,json=periodSec" json:"PeriodSec,omitempty"`
	Ping         *TaskResultPing       `protobuf:"bytes,11,opt,name=Ping,json=ping" json:"Ping,omitempty" xorm:"extends"`
	Traceroute   *TaskResultTraceroute `protobuf:"bytes,12,opt,name=Traceroute,json=traceroute" json:"Traceroute,omitempty" xorm:"extends"`
	Http         *TaskResultHttp       `protobuf:"bytes,13,opt,name=Http,json=http" json:"Http,omitempty" xorm:"extends"`
}

func (m *TaskResult) Reset()                    { *m = TaskResult{} }
func (m *TaskResult) String() string            { return proto.CompactTextString(m) }
func (*TaskResult) ProtoMessage()               {}
func (*TaskResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TaskResult) GetTaskId() int64 {
	if m != nil {
		return m.TaskId
	}
	return 0
}

func (m *TaskResult) GetOrgId() int64 {
	if m != nil {
		return m.OrgId
	}
	return 0
}

func (m *TaskResult) GetType() TaskType {
	if m != nil {
		return m.Type
	}
	return TaskType__
}

func (m *TaskResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *TaskResult) GetErrorCode() TaskResultCode {
	if m != nil {
		return m.ErrorCode
	}
	return TaskResult__
}

func (m *TaskResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *TaskResult) GetScheduleTime() int64 {
	if m != nil {
		return m.ScheduleTime
	}
	return 0
}

func (m *TaskResult) GetStartMs() int64 {
	if m != nil {
		return m.StartMs
	}
	return 0
}

func (m *TaskResult) GetDelayMs() int64 {
	if m != nil {
		return m.DelayMs
	}
	return 0
}

func (m *TaskResult) GetPeriodSec() int64 {
	if m != nil {
		return m.PeriodSec
	}
	return 0
}

func (m *TaskResult) GetPing() *TaskResultPing {
	if m != nil {
		return m.Ping
	}
	return nil
}

func (m *TaskResult) GetTraceroute() *TaskResultTraceroute {
	if m != nil {
		return m.Traceroute
	}
	return nil
}

func (m *TaskResult) GetHttp() *TaskResultHttp {
	if m != nil {
		return m.Http
	}
	return nil
}

type TaskResultHttp struct {
	StatusCode uint32 `protobuf:"varint,1,opt,name=StatusCode,json=statusCode" json:"StatusCode,omitempty"`
}

func (m *TaskResultHttp) Reset()                    { *m = TaskResultHttp{} }
func (m *TaskResultHttp) String() string            { return proto.CompactTextString(m) }
func (*TaskResultHttp) ProtoMessage()               {}
func (*TaskResultHttp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *TaskResultHttp) GetStatusCode() uint32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

type TaskResultPing struct {
	Lost uint32 `protobuf:"varint,1,opt,name=lost" json:"lost,omitempty"`
}

func (m *TaskResultPing) Reset()                    { *m = TaskResultPing{} }
func (m *TaskResultPing) String() string            { return proto.CompactTextString(m) }
func (*TaskResultPing) ProtoMessage()               {}
func (*TaskResultPing) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 1} }

func (m *TaskResultPing) GetLost() uint32 {
	if m != nil {
		return m.Lost
	}
	return 0
}

type TaskResultTraceroute struct {
	Hops    int32 `protobuf:"varint,1,opt,name=Hops,json=hops" json:"Hops,omitempty"`
	ErrHops int32 `protobuf:"varint,2,opt,name=ErrHops,json=errHops" json:"ErrHops,omitempty"`
}

func (m *TaskResultTraceroute) Reset()                    { *m = TaskResultTraceroute{} }
func (m *TaskResultTraceroute) String() string            { return proto.CompactTextString(m) }
func (*TaskResultTraceroute) ProtoMessage()               {}
func (*TaskResultTraceroute) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 2} }

func (m *TaskResultTraceroute) GetHops() int32 {
	if m != nil {
		return m.Hops
	}
	return 0
}

func (m *TaskResultTraceroute) GetErrHops() int32 {
	if m != nil {
		return m.ErrHops
	}
	return 0
}

type HttpSpec struct {
	Url       string             `protobuf:"bytes,1,opt,name=Url,json=url" json:"Url"`
	Method    HttpSpecMethod     `protobuf:"varint,2,opt,name=Method,json=method,enum=HttpSpecMethod" json:"Method"`
	Header    map[string]string  `protobuf:"bytes,3,rep,name=header" json:"header" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Cookies   string             `protobuf:"bytes,4,opt,name=Cookies,json=cookies" json:"Cookies"`
	BasicAuth *HttpSpecBasicAuth `protobuf:"bytes,5,opt,name=BasicAuth,json=basicAuth" json:"BasicAuth" xorm:"json"`
	Body      []byte             `protobuf:"bytes,6,opt,name=Body,json=body,proto3" json:"Body" xorm:"json"`
	IsBodyStr bool               `protobuf:"varint,7,opt,name=IsBodyStr,json=isBodyStr" json:"IsBodyStr"`
	ServerIp  string             `protobuf:"bytes,8,opt,name=ServerIp,json=serverIp" json:"ServerIp"`
	Matcher   *HttpSpecMatcher   `protobuf:"bytes,9,opt,name=Matcher,json=matcher" json:"Matcher" xorm:"json"`
	WebImage  string             `protobuf:"bytes,10,opt,name=WebImage,json=webImage" json:"WebImage"`
}

func (m *HttpSpec) Reset()                    { *m = HttpSpec{} }
func (m *HttpSpec) String() string            { return proto.CompactTextString(m) }
func (*HttpSpec) ProtoMessage()               {}
func (*HttpSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *HttpSpec) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *HttpSpec) GetMethod() HttpSpecMethod {
	if m != nil {
		return m.Method
	}
	return HttpSpec___
}

func (m *HttpSpec) GetHeader() map[string]string {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *HttpSpec) GetCookies() string {
	if m != nil {
		return m.Cookies
	}
	return ""
}

func (m *HttpSpec) GetBasicAuth() *HttpSpecBasicAuth {
	if m != nil {
		return m.BasicAuth
	}
	return nil
}

func (m *HttpSpec) GetBody() []byte {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *HttpSpec) GetIsBodyStr() bool {
	if m != nil {
		return m.IsBodyStr
	}
	return false
}

func (m *HttpSpec) GetServerIp() string {
	if m != nil {
		return m.ServerIp
	}
	return ""
}

func (m *HttpSpec) GetMatcher() *HttpSpecMatcher {
	if m != nil {
		return m.Matcher
	}
	return nil
}

func (m *HttpSpec) SetWebImage(img string) {
	if m != nil {
		 m.WebImage = img
	}
}

func (m *HttpSpec) GetWebImage() string {
	if m != nil {
		return m.WebImage
	}
	return ""
}

type HttpSpecMatcher struct {
	Target     HttpSpecMatcherTarget `protobuf:"varint,1,opt,name=Target,json=target,enum=HttpSpecMatcherTarget" json:"Target,omitempty"`
	Method     HttpSpecMatcherMethod `protobuf:"varint,2,opt,name=Method,json=method,enum=HttpSpecMatcherMethod" json:"Method,omitempty"`
	Content    string                `protobuf:"bytes,3,opt,name=Content,json=content" json:"Content,omitempty"`
	StatusCode int32                 `protobuf:"varint,4,opt,name=StatusCode,json=statusCode" json:"StatusCode,omitempty"`
}

func (m *HttpSpecMatcher) Reset()                    { *m = HttpSpecMatcher{} }
func (m *HttpSpecMatcher) String() string            { return proto.CompactTextString(m) }
func (*HttpSpecMatcher) ProtoMessage()               {}
func (*HttpSpecMatcher) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

func (m *HttpSpecMatcher) GetTarget() HttpSpecMatcherTarget {
	if m != nil {
		return m.Target
	}
	return HttpSpecMatcher____
}

func (m *HttpSpecMatcher) GetMethod() HttpSpecMatcherMethod {
	if m != nil {
		return m.Method
	}
	return HttpSpecMatcher______
}

func (m *HttpSpecMatcher) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *HttpSpecMatcher) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

type HttpSpecBasicAuth struct {
	User   string `protobuf:"bytes,1,opt,name=User,json=user" json:"User,omitempty"`
	Passwd string `protobuf:"bytes,2,opt,name=Passwd,json=passwd" json:"Passwd,omitempty"`
}

func (m *HttpSpecBasicAuth) Reset()                    { *m = HttpSpecBasicAuth{} }
func (m *HttpSpecBasicAuth) String() string            { return proto.CompactTextString(m) }
func (*HttpSpecBasicAuth) ProtoMessage()               {}
func (*HttpSpecBasicAuth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 1} }

func (m *HttpSpecBasicAuth) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *HttpSpecBasicAuth) GetPasswd() string {
	if m != nil {
		return m.Passwd
	}
	return ""
}

type DnsSpec struct {
	Domain         string      `protobuf:"bytes,1,opt,name=Domain,json=domain" json:"Domain,omitempty"`
	Type           DnsSpecType `protobuf:"varint,2,opt,name=Type,json=type,enum=DnsSpecType" json:"Type,omitempty" xorm:"query_type"`
	IfMatchIp      bool        `protobuf:"varint,3,opt,name=IfMatchIp,json=ifMatchIp" json:"IfMatchIp,omitempty"`
	MatchIps       []string    `protobuf:"bytes,4,rep,name=MatchIps,json=matchIps" json:"MatchIps,omitempty"`
	IfMatchDomain  bool        `protobuf:"varint,5,opt,name=IfMatchDomain,json=ifMatchDomain" json:"IfMatchDomain,omitempty"`
	MatchDomains   []string    `protobuf:"bytes,6,rep,name=MatchDomains,json=matchDomains" json:"MatchDomains,omitempty"`
	ServerDesigned bool        `protobuf:"varint,7,opt,name=ServerDesigned,json=serverDesigned" json:"ServerDesigned,omitempty"`
	DNSServer      string      `protobuf:"bytes,8,opt,name=DNSServer,json=dNSServer" json:"DNSServer,omitempty"`
}

func (m *DnsSpec) Reset()                    { *m = DnsSpec{} }
func (m *DnsSpec) String() string            { return proto.CompactTextString(m) }
func (*DnsSpec) ProtoMessage()               {}
func (*DnsSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *DnsSpec) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *DnsSpec) GetType() DnsSpecType {
	if m != nil {
		return m.Type
	}
	return DnsSpec______
}

func (m *DnsSpec) GetIfMatchIp() bool {
	if m != nil {
		return m.IfMatchIp
	}
	return false
}

func (m *DnsSpec) GetMatchIps() []string {
	if m != nil {
		return m.MatchIps
	}
	return nil
}

func (m *DnsSpec) GetIfMatchDomain() bool {
	if m != nil {
		return m.IfMatchDomain
	}
	return false
}

func (m *DnsSpec) GetMatchDomains() []string {
	if m != nil {
		return m.MatchDomains
	}
	return nil
}

func (m *DnsSpec) GetServerDesigned() bool {
	if m != nil {
		return m.ServerDesigned
	}
	return false
}

func (m *DnsSpec) GetDNSServer() string {
	if m != nil {
		return m.DNSServer
	}
	return ""
}

type PingSpec struct {
	Destination string `protobuf:"bytes,1,opt,name=Destination,json=destination" json:"Destination,omitempty"`
	Count       int32  `protobuf:"varint,2,opt,name=Count,json=count" json:"Count,omitempty"`
	Timeout     int32  `protobuf:"varint,3,opt,name=Timeout,json=timeout" json:"Timeout,omitempty"`
}

func (m *PingSpec) Reset()                    { *m = PingSpec{} }
func (m *PingSpec) String() string            { return proto.CompactTextString(m) }
func (*PingSpec) ProtoMessage()               {}
func (*PingSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *PingSpec) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

func (m *PingSpec) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PingSpec) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

type TraceRouteSpec struct {
	Destination string `protobuf:"bytes,1,opt,name=Destination,json=destination" json:"Destination,omitempty"`
}

func (m *TraceRouteSpec) Reset()                    { *m = TraceRouteSpec{} }
func (m *TraceRouteSpec) String() string            { return proto.CompactTextString(m) }
func (*TraceRouteSpec) ProtoMessage()               {}
func (*TraceRouteSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TraceRouteSpec) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type TcpSpec struct {
	Host string `protobuf:"bytes,1,opt,name=Host,json=host" json:"Host,omitempty"`
	Port int32  `protobuf:"varint,2,opt,name=Port,json=port" json:"Port,omitempty"`
}

func (m *TcpSpec) Reset()                    { *m = TcpSpec{} }
func (m *TcpSpec) String() string            { return proto.CompactTextString(m) }
func (*TcpSpec) ProtoMessage()               {}
func (*TcpSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *TcpSpec) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *TcpSpec) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type UdpSpec struct {
	Host            string        `protobuf:"bytes,1,opt,name=Host,json=host" json:"Host,omitempty"`
	Port            int32         `protobuf:"varint,2,opt,name=Port,json=port" json:"Port,omitempty"`
	ReqFormat       UdpSpecFormat `protobuf:"varint,3,opt,name=ReqFormat,json=reqFormat,enum=UdpSpecFormat" json:"ReqFormat,omitempty"`
	ReqContent      string        `protobuf:"bytes,4,opt,name=ReqContent,json=reqContent" json:"ReqContent,omitempty"`
	ResFormat       UdpSpecFormat `protobuf:"varint,5,opt,name=ResFormat,json=resFormat,enum=UdpSpecFormat" json:"ResFormat,omitempty"`
	ResMatchContent string        `protobuf:"bytes,6,opt,name=ResMatchContent,json=resMatchContent" json:"ResMatchContent,omitempty"`
}

func (m *UdpSpec) Reset()                    { *m = UdpSpec{} }
func (m *UdpSpec) String() string            { return proto.CompactTextString(m) }
func (*UdpSpec) ProtoMessage()               {}
func (*UdpSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UdpSpec) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *UdpSpec) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *UdpSpec) GetReqFormat() UdpSpecFormat {
	if m != nil {
		return m.ReqFormat
	}
	return UdpSpec__
}

func (m *UdpSpec) GetReqContent() string {
	if m != nil {
		return m.ReqContent
	}
	return ""
}

func (m *UdpSpec) GetResFormat() UdpSpecFormat {
	if m != nil {
		return m.ResFormat
	}
	return UdpSpec__
}

func (m *UdpSpec) GetResMatchContent() string {
	if m != nil {
		return m.ResMatchContent
	}
	return ""
}

type FtpSpec struct {
	Host   string       `protobuf:"bytes,1,opt,name=Host,json=host" json:"Host,omitempty"`
	Port   int32        `protobuf:"varint,2,opt,name=Port,json=port" json:"Port,omitempty"`
	IfAuth bool         `protobuf:"varint,3,opt,name=IfAuth,json=ifAuth" json:"IfAuth,omitempty"`
	Auth   *FtpSpecAuth `protobuf:"bytes,4,opt,name=Auth,json=auth" json:"Auth,omitempty"`
}

func (m *FtpSpec) Reset()                    { *m = FtpSpec{} }
func (m *FtpSpec) String() string            { return proto.CompactTextString(m) }
func (*FtpSpec) ProtoMessage()               {}
func (*FtpSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *FtpSpec) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *FtpSpec) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *FtpSpec) GetIfAuth() bool {
	if m != nil {
		return m.IfAuth
	}
	return false
}

func (m *FtpSpec) GetAuth() *FtpSpecAuth {
	if m != nil {
		return m.Auth
	}
	return nil
}

type FtpSpecAuth struct {
	User   string `protobuf:"bytes,1,opt,name=User,json=user" json:"User,omitempty"`
	Passwd string `protobuf:"bytes,2,opt,name=Passwd,json=passwd" json:"Passwd,omitempty"`
}

func (m *FtpSpecAuth) Reset()                    { *m = FtpSpecAuth{} }
func (m *FtpSpecAuth) String() string            { return proto.CompactTextString(m) }
func (*FtpSpecAuth) ProtoMessage()               {}
func (*FtpSpecAuth) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10, 0} }

func (m *FtpSpecAuth) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *FtpSpecAuth) GetPasswd() string {
	if m != nil {
		return m.Passwd
	}
	return ""
}

func init() {
	proto.RegisterType((*Topic)(nil), "Topic")
	proto.RegisterType((*Task)(nil), "Task")
	proto.RegisterType((*BasicInfo)(nil), "BasicInfo")
	proto.RegisterType((*TaskResult)(nil), "taskResult")
	proto.RegisterType((*TaskResultHttp)(nil), "taskResult.http")
	proto.RegisterType((*TaskResultPing)(nil), "taskResult.ping")
	proto.RegisterType((*TaskResultTraceroute)(nil), "taskResult.traceroute")
	proto.RegisterType((*HttpSpec)(nil), "HttpSpec")
	proto.RegisterType((*HttpSpecMatcher)(nil), "HttpSpec.matcher")
	proto.RegisterType((*HttpSpecBasicAuth)(nil), "HttpSpec.basicAuth")
	proto.RegisterType((*DnsSpec)(nil), "DnsSpec")
	proto.RegisterType((*PingSpec)(nil), "PingSpec")
	proto.RegisterType((*TraceRouteSpec)(nil), "TraceRouteSpec")
	proto.RegisterType((*TcpSpec)(nil), "TcpSpec")
	proto.RegisterType((*UdpSpec)(nil), "UdpSpec")
	proto.RegisterType((*FtpSpec)(nil), "FtpSpec")
	proto.RegisterType((*FtpSpecAuth)(nil), "FtpSpec.auth")
	proto.RegisterEnum("TaskType", TaskType_name, TaskType_value)
	proto.RegisterEnum("TopicType", TopicType_name, TopicType_value)
	proto.RegisterEnum("TaskResultCode", TaskResultCode_name, TaskResultCode_value)
	proto.RegisterEnum("HttpSpecMethod", HttpSpecMethod_name, HttpSpecMethod_value)
	proto.RegisterEnum("HttpSpecMatcherTarget", HttpSpecMatcherTarget_name, HttpSpecMatcherTarget_value)
	proto.RegisterEnum("HttpSpecMatcherMethod", HttpSpecMatcherMethod_name, HttpSpecMatcherMethod_value)
	proto.RegisterEnum("DnsSpecType", DnsSpecType_name, DnsSpecType_value)
	proto.RegisterEnum("UdpSpecFormat", UdpSpecFormat_name, UdpSpecFormat_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for MasterWorker service

type MasterWorkerClient interface {
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (MasterWorker_SubscribeClient, error)
}

type masterWorkerClient struct {
	cc *grpc.ClientConn
}

func NewMasterWorkerClient(cc *grpc.ClientConn) MasterWorkerClient {
	return &masterWorkerClient{cc}
}

func (c *masterWorkerClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (MasterWorker_SubscribeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_MasterWorker_serviceDesc.Streams[0], c.cc, "/MasterWorker/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &masterWorkerSubscribeClient{stream}
	return x, nil
}

type MasterWorker_SubscribeClient interface {
	Send(*Topic) error
	Recv() (*Task, error)
	grpc.ClientStream
}

type masterWorkerSubscribeClient struct {
	grpc.ClientStream
}

func (x *masterWorkerSubscribeClient) Send(m *Topic) error {
	return x.ClientStream.SendMsg(m)
}

func (x *masterWorkerSubscribeClient) Recv() (*Task, error) {
	m := new(Task)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for MasterWorker service

type MasterWorkerServer interface {
	Subscribe(MasterWorker_SubscribeServer) error
}

func RegisterMasterWorkerServer(s *grpc.Server, srv MasterWorkerServer) {
	s.RegisterService(&_MasterWorker_serviceDesc, srv)
}

func _MasterWorker_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MasterWorkerServer).Subscribe(&masterWorkerSubscribeServer{stream})
}

type MasterWorker_SubscribeServer interface {
	Send(*Task) error
	Recv() (*Topic, error)
	grpc.ServerStream
}

type masterWorkerSubscribeServer struct {
	grpc.ServerStream
}

func (x *masterWorkerSubscribeServer) Send(m *Task) error {
	return x.ServerStream.SendMsg(m)
}

func (x *masterWorkerSubscribeServer) Recv() (*Topic, error) {
	m := new(Topic)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _MasterWorker_serviceDesc = grpc.ServiceDesc{
	ServiceName: "MasterWorker",
	HandlerType: (*MasterWorkerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _MasterWorker_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "master_worker.proto",
}

func init() { proto.RegisterFile("master_worker.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1754 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x57, 0xdd, 0x8e, 0xe3, 0xb6,
	0x15, 0x8e, 0x7e, 0x2c, 0x59, 0x47, 0x33, 0x1e, 0x85, 0xbb, 0xd9, 0xba, 0xc6, 0xb6, 0x75, 0xd5,
	0x24, 0x30, 0x5a, 0xac, 0xb1, 0x71, 0x81, 0xa6, 0xc9, 0x9d, 0xd7, 0xd6, 0xc6, 0x46, 0x76, 0x6c,
	0x97, 0x96, 0x9b, 0x4d, 0x51, 0xc0, 0xd0, 0x58, 0x9c, 0x19, 0x63, 0xc6, 0x96, 0x43, 0xd2, 0x3b,
	0x9d, 0xbb, 0xbe, 0x40, 0xdf, 0xa1, 0x0f, 0x53, 0xa0, 0x4f, 0x50, 0xf4, 0x15, 0xfa, 0x10, 0x2d,
	0x50, 0x1c, 0x92, 0x92, 0x3d, 0xbb, 0x1b, 0x34, 0xbd, 0x91, 0x78, 0xbe, 0xf3, 0x91, 0x22, 0xcf,
	0x1f, 0x8f, 0xe0, 0xd1, 0x26, 0x13, 0x92, 0xf1, 0xe5, 0x5d, 0xc1, 0x6f, 0x18, 0xef, 0xee, 0x78,
	0x21, 0x8b, 0xf8, 0x6f, 0x16, 0xd4, 0xd2, 0x62, 0xb7, 0x5e, 0x91, 0x9f, 0x81, 0x9b, 0xde, 0xef,
	0x58, 0xd3, 0x6a, 0x5b, 0x9d, 0x46, 0x2f, 0xec, 0x2a, 0xb4, 0x2b, 0xef, 0x77, 0x8c, 0xba, 0xf8,
	0x24, 0x2d, 0xa8, 0x7f, 0xa3, 0xa6, 0x8e, 0xf3, 0xa6, 0xdd, 0xb6, 0x3a, 0x0e, 0xad, 0xdf, 0x19,
	0x99, 0xfc, 0x14, 0x40, 0xeb, 0xd2, 0xf5, 0x86, 0x35, 0x1d, 0xa5, 0x85, 0xbb, 0x0a, 0x21, 0xbf,
	0x00, 0x8f, 0x33, 0xb1, 0xbf, 0x95, 0x4d, 0xb7, 0x6d, 0x75, 0xc2, 0x5e, 0xd8, 0x95, 0x99, 0xb8,
	0xa1, 0x0a, 0xa2, 0x46, 0x15, 0x7f, 0x01, 0xfa, 0x43, 0x35, 0xb0, 0x96, 0xd1, 0x07, 0x24, 0x04,
	0x7f, 0x30, 0x9d, 0x4c, 0x92, 0x41, 0x1a, 0x59, 0x04, 0xc0, 0xa3, 0xc9, 0x7c, 0xf1, 0x2a, 0x8d,
	0x6c, 0xf2, 0x21, 0x9c, 0x8e, 0x92, 0xfe, 0xab, 0x74, 0xb4, 0xa4, 0xc9, 0x6c, 0x4a, 0xd3, 0xc8,
	0x89, 0xff, 0x6e, 0x83, 0x9b, 0x66, 0xe2, 0x86, 0x74, 0x20, 0x78, 0x91, 0x89, 0xf5, 0x6a, 0xbc,
	0xbd, 0x2c, 0xd4, 0x51, 0xc2, 0x1e, 0x74, 0x2b, 0x84, 0x06, 0x17, 0xe5, 0x90, 0x7c, 0x02, 0xf5,
	0x91, 0x94, 0xbb, 0xf9, 0x8e, 0xad, 0xd4, 0x71, 0xc2, 0x5e, 0xd0, 0x2d, 0x01, 0x5a, 0xbf, 0x36,
	0x23, 0x12, 0x83, 0x3f, 0xdc, 0x0a, 0xc5, 0x72, 0x14, 0xab, 0xde, 0x35, 0x32, 0xf5, 0x73, 0x3d,
	0xc0, 0xa5, 0x66, 0xeb, 0xed, 0x95, 0x22, 0xb9, 0x66, 0xa9, 0x12, 0xa0, 0xf5, 0x9d, 0x19, 0x91,
	0xcf, 0xa1, 0x91, 0xf2, 0x6c, 0xc5, 0x78, 0xb1, 0x97, 0x4c, 0x91, 0x6b, 0x8a, 0x7c, 0xd6, 0x55,
	0x30, 0x2d, 0x61, 0xda, 0x90, 0x0f, 0x68, 0xb8, 0x87, 0x74, 0xa5, 0x77, 0xea, 0x99, 0x3d, 0x18,
	0x99, 0xfa, 0x72, 0x55, 0xed, 0x73, 0x91, 0x6b, 0x8e, 0x6f, 0x38, 0x46, 0xa6, 0xfe, 0x3e, 0xaf,
	0x38, 0x2f, 0xcd, 0x89, 0xeb, 0x86, 0x63, 0x64, 0xea, 0x5f, 0xea, 0x41, 0xfc, 0x2f, 0xfb, 0xc8,
	0x82, 0xa4, 0x01, 0xf6, 0x38, 0x57, 0x76, 0x74, 0xa8, 0xbd, 0xce, 0xc9, 0x63, 0xa8, 0x4d, 0xf9,
	0x55, 0x15, 0x00, 0xb5, 0x02, 0x05, 0xf2, 0x04, 0xbc, 0x49, 0x91, 0xb3, 0x71, 0x6e, 0x3c, 0xef,
	0x6d, 0x95, 0x44, 0x7e, 0x62, 0x42, 0xca, 0x55, 0x21, 0x15, 0x74, 0xd1, 0x43, 0xe9, 0x21, 0xa0,
	0x08, 0xb8, 0x93, 0x6c, 0xc3, 0x94, 0x15, 0x02, 0xea, 0x6e, 0xb3, 0x0d, 0x23, 0x4d, 0xf0, 0x7f,
	0xcf, 0xb8, 0x58, 0x17, 0x5b, 0x75, 0xd4, 0x80, 0xfa, 0x6f, 0xb4, 0x88, 0x21, 0x36, 0xe0, 0x2c,
	0x93, 0x4c, 0x85, 0x98, 0xaf, 0x43, 0x6c, 0x55, 0x21, 0xa8, 0x5f, 0xec, 0xf2, 0x52, 0x5f, 0xd7,
	0xfa, 0x7d, 0x85, 0x90, 0x36, 0x84, 0xc9, 0x9f, 0xd8, 0x6a, 0x6f, 0x08, 0x81, 0x22, 0x84, 0xec,
	0x00, 0x91, 0x18, 0x4e, 0xe6, 0xab, 0x6b, 0x96, 0xef, 0x6f, 0x35, 0x05, 0x14, 0xe5, 0x44, 0x1c,
	0x61, 0xe4, 0x29, 0x04, 0x33, 0xc6, 0xd7, 0x45, 0x3e, 0x67, 0xab, 0x66, 0xa8, 0x08, 0xc1, 0xae,
	0x04, 0xf0, 0x44, 0x73, 0x59, 0xec, 0x9a, 0x27, 0x6d, 0xab, 0x53, 0xa7, 0xae, 0x90, 0xc5, 0x0e,
	0x4f, 0x44, 0xf7, 0xb7, 0x6c, 0x9c, 0x8b, 0xe6, 0x69, 0xdb, 0xe9, 0x38, 0xd4, 0xe7, 0x5a, 0x8c,
	0xff, 0xe2, 0x03, 0x1c, 0xd2, 0x00, 0xad, 0x88, 0x06, 0xaa, 0xec, 0xed, 0x49, 0x25, 0x7d, 0x8f,
	0xcd, 0x4b, 0xdb, 0x3a, 0xef, 0xb7, 0x6d, 0x13, 0xfc, 0xf9, 0x7e, 0xb5, 0x62, 0x42, 0x28, 0xeb,
	0xd7, 0xa9, 0x2f, 0xb4, 0x48, 0xba, 0x10, 0x24, 0x9c, 0x17, 0x7c, 0x50, 0xe4, 0xda, 0xf4, 0x8d,
	0x5e, 0x74, 0x94, 0x8d, 0xdd, 0x55, 0x91, 0x33, 0x1a, 0xb0, 0x92, 0x82, 0x9f, 0x57, 0x7c, 0xe3,
	0x8f, 0x9a, 0xd2, 0xbc, 0x63, 0x2b, 0xff, 0x3d, 0xb6, 0xc2, 0x3d, 0xc8, 0x8c, 0xcb, 0x73, 0x61,
	0xdc, 0xe1, 0x0b, 0x2d, 0xa2, 0x66, 0xc8, 0x6e, 0xb3, 0xfb, 0x73, 0x61, 0xfc, 0xe0, 0xe7, 0x5a,
	0x7c, 0x68, 0x5f, 0x78, 0xdb, 0xbe, 0x1f, 0x83, 0x8b, 0x79, 0xa5, 0x0c, 0x1f, 0x3e, 0xdc, 0x36,
	0x66, 0x19, 0x75, 0xf1, 0x49, 0x7e, 0x03, 0x70, 0xc8, 0x33, 0xe5, 0x8b, 0xb0, 0xf7, 0xe4, 0x98,
	0x7b, 0x48, 0x2f, 0x0a, 0x87, 0x31, 0xae, 0x8e, 0x05, 0xa0, 0x79, 0xfa, 0xee, 0xea, 0x58, 0x0e,
	0xa8, 0x8b, 0xcf, 0xd6, 0xa7, 0xa0, 0xde, 0x18, 0x6f, 0x73, 0x99, 0xc9, 0xbd, 0x50, 0x86, 0x44,
	0x97, 0x9d, 0x52, 0x10, 0x15, 0xd2, 0x6a, 0x81, 0xde, 0x0d, 0x01, 0xf7, 0xb6, 0x10, 0xd2, 0x30,
	0xd4, 0xb8, 0xf5, 0x25, 0x1c, 0x7f, 0x97, 0x80, 0x3b, 0x2a, 0x76, 0x42, 0x31, 0x6a, 0xd4, 0xbd,
	0x2e, 0x76, 0xca, 0x42, 0x09, 0xe7, 0x0a, 0xb6, 0x15, 0xec, 0x33, 0x2d, 0xc6, 0xff, 0xb4, 0xc1,
	0x45, 0x1f, 0x95, 0x65, 0xd2, 0x03, 0x7b, 0xfa, 0x75, 0x64, 0x91, 0x26, 0x3c, 0x4e, 0x28, 0x5d,
	0x8e, 0xd2, 0x74, 0xb6, 0x9c, 0x24, 0xdf, 0x2c, 0x69, 0xf2, 0xbb, 0x45, 0x32, 0xc7, 0x7a, 0xf9,
	0x23, 0x78, 0x54, 0x69, 0x86, 0xd3, 0x4a, 0xe1, 0x90, 0x27, 0x40, 0x2a, 0x05, 0x4d, 0xfa, 0xc3,
	0xe5, 0x8b, 0xe9, 0xf0, 0xdb, 0xc8, 0x25, 0x6d, 0x78, 0x5a, 0xe1, 0xf3, 0xb4, 0x9f, 0x2e, 0xe6,
	0xcb, 0xc1, 0x74, 0x98, 0x2c, 0x17, 0x93, 0xf3, 0x7e, 0x3a, 0x18, 0x45, 0x35, 0xf2, 0x63, 0xf8,
	0xa8, 0x62, 0x8c, 0x70, 0x66, 0xa9, 0xf2, 0x1e, 0xa8, 0x70, 0xbd, 0x4a, 0xe5, 0x93, 0xc7, 0x10,
	0x55, 0xaa, 0x74, 0x7c, 0x9e, 0x4c, 0x17, 0x69, 0x54, 0x27, 0x04, 0x1a, 0x15, 0x3a, 0x4d, 0x47,
	0x09, 0x8d, 0x02, 0x12, 0xc1, 0x09, 0x62, 0x93, 0x24, 0x5d, 0x0e, 0xc7, 0xfd, 0x57, 0x11, 0x90,
	0x47, 0x70, 0x86, 0xc8, 0x62, 0x38, 0xab, 0x0e, 0x10, 0x96, 0x0b, 0x6a, 0x70, 0x3e, 0x9b, 0x4e,
	0xe6, 0x49, 0x74, 0x42, 0x9e, 0x42, 0xf3, 0x6d, 0xb4, 0xda, 0xc4, 0x69, 0x69, 0xa7, 0x97, 0xe9,
	0x6c, 0xb9, 0x98, 0xf4, 0x17, 0xe9, 0x68, 0x4a, 0xc7, 0x7f, 0x48, 0x86, 0x51, 0x23, 0xfe, 0x77,
	0xed, 0x70, 0x25, 0x90, 0x08, 0x9c, 0x05, 0xbf, 0x55, 0x3e, 0x09, 0xa8, 0xb3, 0xe7, 0xb7, 0xa4,
	0x03, 0xde, 0x39, 0x93, 0xd7, 0x85, 0x4e, 0x44, 0xcc, 0x9a, 0x92, 0xdc, 0xdd, 0x28, 0x9c, 0x7a,
	0xfa, 0x4d, 0x9e, 0x81, 0x77, 0xcd, 0xb2, 0x9c, 0xf1, 0xa6, 0xd3, 0x76, 0x3a, 0x61, 0xef, 0xa3,
	0x03, 0x73, 0xa4, 0xf0, 0x64, 0x2b, 0xf9, 0x3d, 0x35, 0x24, 0xf4, 0xf5, 0xa0, 0x28, 0x6e, 0xd6,
	0x4c, 0xe7, 0x6a, 0x40, 0xfd, 0x95, 0x16, 0xc9, 0x67, 0xa6, 0x16, 0xf7, 0xf7, 0xf2, 0xda, 0x5c,
	0x16, 0x8f, 0x0e, 0x6b, 0x5d, 0x94, 0x2a, 0x73, 0xad, 0xe1, 0x10, 0x83, 0xe9, 0x45, 0x91, 0xdf,
	0xab, 0x6c, 0x3d, 0xa1, 0xee, 0x45, 0x91, 0xdf, 0x63, 0x52, 0x8d, 0x05, 0xa2, 0x73, 0xc9, 0x55,
	0xa6, 0xd6, 0x69, 0xb0, 0x2e, 0x01, 0xbc, 0xd7, 0xe7, 0x8c, 0xbf, 0x61, 0x7c, 0xbc, 0x53, 0x79,
	0x1a, 0xd0, 0xba, 0x30, 0x32, 0xf9, 0x15, 0xf8, 0xe7, 0x99, 0x5c, 0x5d, 0x33, 0xae, 0x12, 0x35,
	0xec, 0x7d, 0x78, 0x74, 0x68, 0xad, 0xa0, 0xbe, 0x19, 0xa8, 0x06, 0x81, 0x5d, 0x8c, 0x37, 0xd9,
	0x95, 0xae, 0x9d, 0x01, 0xad, 0xdf, 0x19, 0xb9, 0xf5, 0x1f, 0x0b, 0x2a, 0xde, 0x73, 0x2c, 0x74,
	0xfc, 0x8a, 0x49, 0xd3, 0x6b, 0x34, 0xdf, 0x59, 0xb3, 0x2b, 0x95, 0x1e, 0x4b, 0x20, 0xbe, 0x71,
	0xc6, 0x03, 0xd3, 0xbf, 0x67, 0xc6, 0x5b, 0x2e, 0x50, 0x36, 0xdd, 0x4a, 0xb6, 0x95, 0xaa, 0x42,
	0x2a, 0x9b, 0x2a, 0xf1, 0xad, 0xbc, 0x75, 0x55, 0x72, 0x1d, 0xe5, 0x6d, 0xfc, 0x09, 0x94, 0x5f,
	0xf5, 0xc1, 0x59, 0x2e, 0x31, 0xc5, 0xea, 0xe0, 0xaa, 0xcc, 0xb0, 0x70, 0x84, 0xe1, 0x1e, 0xd9,
	0xf1, 0x33, 0x28, 0x3f, 0x15, 0x40, 0x6d, 0xb9, 0xd4, 0xc4, 0x10, 0xfc, 0xf1, 0x64, 0xf0, 0x6a,
	0x31, 0x4c, 0x22, 0x0b, 0x85, 0xe4, 0xb5, 0x16, 0xec, 0xd6, 0xe7, 0xf0, 0xd0, 0x47, 0x0b, 0xc1,
	0xb8, 0x09, 0x2e, 0x77, 0x2f, 0x18, 0xc7, 0xea, 0x3f, 0xcb, 0x84, 0xb8, 0xd3, 0x47, 0x0c, 0xa8,
	0xb7, 0x53, 0x52, 0xeb, 0x0b, 0x08, 0x8f, 0x62, 0x06, 0xc3, 0xf2, 0x86, 0xdd, 0x97, 0x61, 0x79,
	0xc3, 0xee, 0xb1, 0x3e, 0xbf, 0xc9, 0x6e, 0xf7, 0xcc, 0xcc, 0xd3, 0xc2, 0x97, 0xf6, 0x6f, 0xad,
	0xa3, 0x2d, 0x7a, 0x60, 0xab, 0xfd, 0xf9, 0xe0, 0x7c, 0x95, 0xa4, 0xfa, 0x1c, 0xb3, 0xa9, 0x2a,
	0x0e, 0xe5, 0x89, 0x9c, 0xf8, 0x1f, 0x76, 0xd5, 0xea, 0xe0, 0x6e, 0x86, 0xc5, 0x26, 0x5b, 0x6f,
	0xcd, 0x97, 0xbc, 0x5c, 0x49, 0xe4, 0xe7, 0xe6, 0xd6, 0xd1, 0x6e, 0x38, 0x2d, 0x5b, 0xa1, 0xe3,
	0x36, 0x11, 0x83, 0xed, 0x52, 0x05, 0xcd, 0x78, 0xa7, 0x6c, 0x8f, 0xc1, 0x56, 0x02, 0x18, 0x23,
	0x66, 0x88, 0xc1, 0xee, 0x60, 0x8c, 0x6c, 0x8c, 0x4c, 0x3e, 0x86, 0x53, 0x33, 0xd3, 0x7c, 0xbb,
	0xa6, 0x66, 0x9f, 0xae, 0x8f, 0x41, 0xbc, 0x79, 0x8e, 0x44, 0xd1, 0xf4, 0xd4, 0x2a, 0x27, 0x9b,
	0x23, 0x8c, 0x7c, 0x0a, 0x0d, 0x1d, 0xd2, 0x43, 0x26, 0xd6, 0x57, 0x5b, 0x96, 0x9b, 0xa8, 0x6f,
	0x88, 0x07, 0x28, 0xee, 0x75, 0x38, 0x99, 0x6b, 0xaa, 0x89, 0xfd, 0x20, 0x2f, 0x81, 0x38, 0x31,
	0xfd, 0xe8, 0x91, 0x83, 0x6b, 0x60, 0xf5, 0x23, 0x0b, 0xed, 0x79, 0xfe, 0x3a, 0xb2, 0xf1, 0x3d,
	0x99, 0x47, 0x0e, 0x32, 0x06, 0x93, 0xfe, 0x79, 0x12, 0xb9, 0x68, 0xe2, 0xf4, 0x75, 0x1a, 0xd5,
	0x70, 0xd0, 0x9f, 0x7c, 0x1b, 0x79, 0xf1, 0x1f, 0x0f, 0xdd, 0x21, 0x36, 0x21, 0x43, 0x26, 0xe4,
	0x7a, 0x9b, 0x49, 0x6c, 0x71, 0xb4, 0x71, 0xc3, 0xfc, 0x00, 0xa1, 0x3b, 0x07, 0xc5, 0x7e, 0x2b,
	0x4d, 0xd9, 0xaf, 0xad, 0x50, 0xc0, 0x70, 0xc6, 0x2b, 0xb5, 0xd8, 0xeb, 0x70, 0xae, 0x51, 0x5f,
	0x6a, 0x31, 0xee, 0x99, 0xa6, 0xb2, 0xea, 0x1e, 0xff, 0xf7, 0x37, 0xe2, 0xcf, 0xaa, 0x7e, 0x52,
	0xdf, 0x3d, 0xe6, 0x76, 0x0a, 0xf0, 0xee, 0x11, 0x12, 0xb1, 0x59, 0xc1, 0xcb, 0x1d, 0xb8, 0xbb,
	0x82, 0xcb, 0xf8, 0xcf, 0x76, 0xd5, 0x5f, 0xfe, 0xd0, 0x39, 0xe4, 0x19, 0x04, 0x94, 0x7d, 0xf7,
	0xb2, 0xe0, 0x9b, 0x4c, 0x9a, 0x3e, 0xe5, 0xac, 0x6c, 0x4a, 0xbb, 0x97, 0x0a, 0xa6, 0x01, 0x2f,
	0x19, 0x98, 0x98, 0x94, 0x7d, 0x57, 0x66, 0xad, 0xae, 0x84, 0xc0, 0x2b, 0x44, 0x2f, 0x27, 0xcc,
	0x72, 0xb5, 0xef, 0x5d, 0xce, 0x30, 0x48, 0x07, 0xce, 0x28, 0x13, 0x2a, 0x54, 0xca, 0x35, 0x75,
	0x07, 0x73, 0xc6, 0x1f, 0xc2, 0x98, 0xf1, 0x7a, 0x7a, 0x79, 0xa5, 0x02, 0x78, 0x2f, 0xc6, 0x93,
	0x3e, 0x35, 0x19, 0x9f, 0x26, 0xaf, 0xd3, 0xc8, 0x8e, 0xff, 0x6a, 0x55, 0xed, 0xf3, 0x0f, 0x36,
	0xc1, 0x13, 0xf0, 0xc6, 0x97, 0xaa, 0x7a, 0xeb, 0x4c, 0xf0, 0xd6, 0x4a, 0xc2, 0x3c, 0x52, 0xa8,
	0xfe, 0x5b, 0x38, 0x2d, 0xdb, 0xf0, 0x6e, 0x86, 0xd5, 0xdc, 0xc5, 0x67, 0xab, 0x07, 0xea, 0xfd,
	0xff, 0x14, 0x8b, 0x5f, 0x6e, 0xa1, 0x5e, 0xf6, 0x81, 0xe5, 0x59, 0x08, 0x34, 0x16, 0x13, 0xf3,
	0xbb, 0x34, 0x18, 0x25, 0x83, 0xaf, 0x4d, 0x15, 0x4b, 0xd3, 0x59, 0x64, 0x63, 0x90, 0x0e, 0x55,
	0x04, 0x63, 0x41, 0x18, 0x4f, 0xbe, 0x8a, 0x5c, 0x72, 0x06, 0x61, 0x4a, 0xfb, 0x83, 0x64, 0x49,
	0xa7, 0x8b, 0x34, 0xd1, 0x81, 0x9c, 0x0e, 0x66, 0x91, 0x87, 0x83, 0xc5, 0x70, 0x16, 0xf9, 0x38,
	0x78, 0x99, 0xce, 0xa2, 0x7a, 0xef, 0x39, 0xe6, 0x22, 0xfe, 0x54, 0xea, 0x9f, 0x3f, 0xd2, 0x86,
	0x60, 0xbe, 0xbf, 0x10, 0x2b, 0xbe, 0xbe, 0x60, 0xc4, 0xd3, 0xbf, 0x90, 0xad, 0x9a, 0xea, 0x4d,
	0xe3, 0x0f, 0x3a, 0xd6, 0x73, 0xeb, 0xc2, 0x53, 0xbf, 0x9d, 0xbf, 0xfe, 0x6f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x15, 0xec, 0xa6, 0x3f, 0x8d, 0x0e, 0x00, 0x00,
}
